# Registry Codegen Design

## Goal

Generate Go code from Minecraft JSON schemas (PrismarineJS data) so that the server works with any Minecraft version through interfaces. Version-specific data is embedded as Go literals at code generation time. Versions are swappable at startup without changing server logic.

## Scope (First Iteration)

Registry types only: blocks, items, entities, biomes, effects, enchantments, foods, particles.

Protocol, recipes, windows, materials, language, and instruments are out of scope for now.

## Architecture Overview

```
internal/gamedata/
    block.go              // Block struct
    item.go               // Item struct
    entity.go             // Entity struct
    biome.go              // Biome struct
    effect.go             // Effect struct
    enchantment.go        // Enchantment struct
    food.go               // Food struct
    particle.go           // Particle struct
    registry.go           // Registry interfaces (BlockRegistry, ItemRegistry, ...)
    gamedata.go           // GameData struct (bundles all registries)
    loader.go             // Version registry: Register(), Load()
    versions/
        pc_1_8/           // Generated — one package per version
            blocks.go
            items.go
            entities.go
            biomes.go
            effects.go
            enchantments.go
            foods.go
            particles.go
            gamedata.go   // New() + init() auto-registration

cmd/codegen/
    main.go               // CLI entry point
    internal/
        schema/            // JSON unmarshaling types (raw JSON shape)
            blocks.go
            items.go
            entities.go
            biomes.go
            effects.go
            enchantments.go
            foods.go
            particles.go
        generator/         // Template execution + file writing
            generator.go
            templates/     // Embedded Go templates (go:embed)
                blocks.go.tmpl
                items.go.tmpl
                entities.go.tmpl
                biomes.go.tmpl
                effects.go.tmpl
                enchantments.go.tmpl
                foods.go.tmpl
                particles.go.tmpl
                gamedata.go.tmpl
```

## Core Types (internal/gamedata/)

### Domain Structs

One struct per registry type. Fields are the union of fields found across versions (optional fields use pointer types or zero values). Example:

```go
// block.go
type Block struct {
    ID          int
    Name        string
    DisplayName string
    Hardness    float64
    StackSize   int
    Diggable    bool
    BoundingBox string
    Material    string
    Transparent bool
    EmitLight   int
    FilterLight int
    Resistance  float64
    Drops       []Drop
}

type Drop struct {
    ID int
}
```

Similar structs for Item, Entity, Biome, Effect, Enchantment, Food, Particle — each in its own file.

### Registry Interfaces

```go
// registry.go
type BlockRegistry interface {
    ByID(id int) (Block, bool)
    ByName(name string) (Block, bool)
    All() []Block
}

type ItemRegistry interface {
    ByID(id int) (Item, bool)
    ByName(name string) (Item, bool)
    All() []Item
}

// ... same pattern for EntityRegistry, BiomeRegistry, EffectRegistry,
//     EnchantmentRegistry, FoodRegistry, ParticleRegistry
```

### GameData Facade

```go
// gamedata.go
type GameData struct {
    Blocks       BlockRegistry
    Items        ItemRegistry
    Entities     EntityRegistry
    Biomes       BiomeRegistry
    Effects      EffectRegistry
    Enchantments EnchantmentRegistry
    Foods        FoodRegistry
    Particles    ParticleRegistry
}
```

### Version Loader

```go
// loader.go
var versions = map[string]func() *GameData{}

func Register(name string, factory func() *GameData) {
    versions[name] = factory
}

func Load(name string) (*GameData, error) {
    f, ok := versions[name]
    if !ok {
        return nil, fmt.Errorf("unknown version: %s", name)
    }
    return f(), nil
}
```

## Generated Code (per version)

Each version package implements all registry interfaces with embedded data. Example for blocks:

```go
// internal/gamedata/versions/pc_1_8/blocks.go
// Code generated by cmd/codegen; DO NOT EDIT.
package pc_1_8

import "github.com/OCharnyshevich/minecraft-server/internal/gamedata"

type blockRegistry struct {
    byID   map[int]gamedata.Block
    byName map[string]gamedata.Block
    all    []gamedata.Block
}

func newBlockRegistry() gamedata.BlockRegistry {
    all := []gamedata.Block{
        {ID: 0, Name: "air", DisplayName: "Air", Hardness: 0, ...},
        {ID: 1, Name: "stone", DisplayName: "Stone", Hardness: 1.5, ...},
        // ... all entries from blocks.json
    }
    byID := make(map[int]gamedata.Block, len(all))
    byName := make(map[string]gamedata.Block, len(all))
    for _, b := range all {
        byID[b.ID] = b
        byName[b.Name] = b
    }
    return &blockRegistry{byID: byID, byName: byName, all: all}
}

func (r *blockRegistry) ByID(id int) (gamedata.Block, bool)       { v, ok := r.byID[id]; return v, ok }
func (r *blockRegistry) ByName(name string) (gamedata.Block, bool) { v, ok := r.byName[name]; return v, ok }
func (r *blockRegistry) All() []gamedata.Block                     { return r.all }
```

Factory with auto-registration:

```go
// internal/gamedata/versions/pc_1_8/gamedata.go
// Code generated by cmd/codegen; DO NOT EDIT.
package pc_1_8

import "github.com/OCharnyshevich/minecraft-server/internal/gamedata"

func init() {
    gamedata.Register("pc-1.8", New)
}

func New() *gamedata.GameData {
    return &gamedata.GameData{
        Blocks:       newBlockRegistry(),
        Items:        newItemRegistry(),
        Entities:     newEntityRegistry(),
        Biomes:       newBiomeRegistry(),
        Effects:      newEffectRegistry(),
        Enchantments: newEnchantmentRegistry(),
        Foods:        newFoodRegistry(),
        Particles:    newParticleRegistry(),
    }
}
```

## Codegen Tool (cmd/codegen/)

### CLI Interface

```
go run ./cmd/codegen -scheme ./scheme/pc-1.8 -out ./internal/gamedata/versions
```

**Flags:**
- `-scheme` — path to the scheme directory containing JSON files
- `-out` — output base directory for generated version packages
- `-pkg` — package name override (default: auto-derived from scheme dir name, e.g. `pc-1.8` -> `pc_1_8`)

### How It Works

1. Parse CLI flags, derive package name from scheme directory name
2. For each registry type (blocks, items, ...):
   a. Read the corresponding JSON file from the scheme directory
   b. Unmarshal into intermediate schema structs (match raw JSON shape)
   c. Execute the Go template, passing the data + package name
   d. Write the rendered `.go` file to the output directory
3. Generate the `gamedata.go` factory file
4. Run `gofumpt` on all generated files

### Template Strategy

Templates are embedded via `go:embed` in the generator package. Each template produces a complete `.go` file including the package declaration, imports, struct definition, constructor with all data literals, and interface methods.

## Task Integration

`Taskfile.codegen.yml` gets a new task:

```yaml
codegen:
  desc: Generate Go code from Minecraft schemas
  cmds:
    - go run ./cmd/codegen -scheme ./scheme/pc-1.8 -out ./internal/gamedata/versions
```

## Usage in Server Code

```go
import (
    "github.com/OCharnyshevich/minecraft-server/internal/gamedata"
    _ "github.com/OCharnyshevich/minecraft-server/internal/gamedata/versions/pc_1_8"
)

func main() {
    gd, err := gamedata.Load("pc-1.8")
    if err != nil {
        log.Fatal(err)
    }

    stone, ok := gd.Blocks.ByName("stone")
    // stone.Hardness == 1.5, stone.ID == 1, etc.
}
```

To support a new version: run `task gen:dmd` with different version flags, then `task codegen`. The new version auto-registers and is available via `gamedata.Load()`.

## Implementation Order

1. Hand-write `internal/gamedata/` — domain structs, interfaces, GameData, loader
2. Build `cmd/codegen/` — schema types, templates, generator
3. Run codegen against `scheme/pc-1.8/`, verify output compiles
4. Write tests: registry lookup tests, Load() tests
5. Integrate into Taskfile
